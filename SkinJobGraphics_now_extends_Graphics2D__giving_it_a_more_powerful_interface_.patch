Index: src/share/classes/java/awt/SkinJobComponentPeer.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/share/classes/java/awt/SkinJobComponentPeer.java	(date 1476782717000)
+++ src/share/classes/java/awt/SkinJobComponentPeer.java	(revision )
@@ -20,6 +20,7 @@
   protected final T androidWidget;
   protected GraphicsConfiguration graphicsConfiguration;
   protected volatile int foregroundColor = SkinJob.defaultForegroundColor;
+  protected Font font = SkinJob.defaultFont;
 
   public SkinJobComponentPeer(T androidWidget, GraphicsConfiguration configuration) {
     this.androidWidget = androidWidget;
@@ -78,7 +79,7 @@
 
   @Override
   public void setFont(Font f) {
-    // TODO
+    font = f;
   }
 
   @Override
Index: src/share/classes/java/awt/SkinJobGraphics.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/share/classes/java/awt/SkinJobGraphics.java	(date 1476782717000)
+++ src/share/classes/java/awt/SkinJobGraphics.java	(revision )
@@ -1,12 +1,30 @@
 package java.awt;
 
+import static java.awt.BasicStroke.CAP_BUTT;
+import static java.awt.BasicStroke.CAP_ROUND;
+import static java.awt.BasicStroke.CAP_SQUARE;
+import static java.awt.BasicStroke.JOIN_BEVEL;
+import static java.awt.BasicStroke.JOIN_MITER;
+import static java.awt.BasicStroke.JOIN_ROUND;
+
 import android.graphics.Bitmap;
 import android.graphics.Canvas;
 import android.graphics.Paint;
+import android.graphics.Paint.Cap;
+import android.graphics.Paint.Join;
 import android.graphics.Paint.Style;
 import android.text.SpannableStringBuilder;
+import android.util.Log;
 import android.widget.TextView;
+import java.awt.font.FontRenderContext;
+import java.awt.font.GlyphVector;
+import java.awt.geom.AffineTransform;
+import java.awt.geom.Rectangle2D;
+import java.awt.image.BufferedImage;
+import java.awt.image.BufferedImageOp;
 import java.awt.image.ImageObserver;
+import java.awt.image.RenderedImage;
+import java.awt.image.renderable.RenderableImage;
 import java.text.AttributedCharacterIterator;
 import java.text.AttributedCharacterIterator.Attribute;
 import java.text.CharacterIterator;
@@ -19,7 +37,7 @@
 /**
  * SkinJob Android implementation of {@link Graphics}.
  */
-public class SkinJobGraphics extends Graphics {
+public class SkinJobGraphics extends Graphics2D {
   private static final String TAG = "SkinJobGraphics";
   private final Set<CancelableImageObserver> pendingObservers = Collections.synchronizedSet(
       Collections.newSetFromMap(new WeakHashMap<>()));
@@ -27,7 +45,13 @@
   private final android.graphics.Paint pen;
   private final android.graphics.Paint brush;
   private final android.graphics.Paint eraser;
+  private final RenderingHints renderingHints = SkinJob.defaultRenderingHints;
+  private Stroke stroke = new BasicStroke();
+  private java.awt.Paint awtPaint;
   private int color = Color.BLACK.getRGB();
+  private Shape clip;
+  private AffineTransform transform = new AffineTransform();
+  private Font font = SkinJob.defaultFont;
 
   public SkinJobGraphics(Bitmap androidBitmap) {
     pen = new android.graphics.Paint();
@@ -39,6 +63,7 @@
     eraser.setStyle(Style.FILL);
     eraser.setAlpha(0);
     canvas = new Canvas(androidBitmap);
+    clip = new Rectangle2D.Double(0, 0, androidBitmap.getWidth(), androidBitmap.getHeight());
   }
 
   @Override
@@ -47,20 +72,13 @@
   }
 
   @Override
-  public void translate(int x, int y) {
-    canvas.translate(x, y);
-  }
-
-  @Override
   public Color getColor() {
     return new Color(color, true);
   }
 
   @Override
   public synchronized void setColor(Color c) {
-    color = c.getRGB();
-    pen.setColor(color);
-    brush.setColor(color);
+    setColor(c.getRGB());
   }
 
   @Override
@@ -75,12 +93,12 @@
 
   @Override
   public Font getFont() {
-    return null;
+    return font;
   }
 
   @Override
   public void setFont(Font font) {
-
+    this.font = font;
   }
 
   @Override
@@ -90,32 +108,33 @@
 
   @Override
   public Rectangle getClipBounds() {
-    return null;
+    // TODO
+    return clip.getBounds();
   }
 
   @Override
   public void clipRect(int x, int y, int width, int height) {
-
+    // TODO
   }
 
   @Override
   public void setClip(int x, int y, int width, int height) {
-
+    clip = new Rectangle2D.Double(x, y, width, height);
   }
 
   @Override
   public Shape getClip() {
-    return null;
+    return clip;
   }
 
   @Override
   public void setClip(Shape clip) {
-
+    this.clip = clip;
   }
 
   @Override
   public void copyArea(int x, int y, int width, int height, int dx, int dy) {
-
+    // TODO
   }
 
   @Override
@@ -182,31 +201,6 @@
   }
 
   @Override
-  public void drawString(String str, int x, int y) {
-    canvas.drawText(str, x, y, brush);
-  }
-
-  @Override
-  public synchronized void drawString(AttributedCharacterIterator iterator, int x, int y) {
-    SpannableStringBuilder formattedText = new SpannableStringBuilder();
-    int charsWritten = 0;
-    for (char c = iterator.first(); c != CharacterIterator.DONE; c = iterator.next()) {
-      formattedText.append(c);
-      charsWritten++;
-      Map<Attribute, Object> attributes = iterator.getAttributes();
-      if (!attributes.isEmpty()) {
-        new SkinJobTextAttributesDecoder(color)
-            .addAttributes(attributes)
-            .applyTo(formattedText, charsWritten - 1, charsWritten);
-      }
-    }
-    TextView formattedTextView = new TextView(SkinJob.getAndroidApplicationContext());
-    formattedTextView.setText(formattedText);
-    formattedTextView.layout(x, y, canvas.getWidth(), canvas.getHeight());
-    formattedTextView.draw(canvas);
-  }
-
-  @Override
   public boolean drawImage(Image img, int x, int y, ImageObserver observer) {
     // TODO
     return false;
@@ -276,6 +270,266 @@
     for (CancelableImageObserver observer : pendingObservers) {
       observer.cancel();
     }
+  }
+
+  public synchronized void setColor(int color) {
+    pen.setColor(color);
+    brush.setColor(color);
+  }
+
+  @Override
+  public void draw(Shape s) {
+    fill(stroke.createStrokedShape(s));
+  }
+
+  @Override
+  public boolean drawImage(
+      Image img, AffineTransform xform, ImageObserver obs) {
+    // TODO
+    return false;
+  }
+
+  @Override
+  public void drawImage(
+      BufferedImage img, BufferedImageOp op, int x, int y) {
+    Rectangle2D filteredSize = op.getBounds2D(img);
+    BufferedImage filtered = new BufferedImage(
+        (int) filteredSize.getWidth(),
+        (int) filteredSize.getHeight(),
+        img.getType());
+    op.filter(img, filtered);
+    drawImage(filtered, x, y, null);
+  }
+
+  @Override
+  public void drawRenderedImage(RenderedImage img, AffineTransform xform) {
+    // TODO
+  }
+
+  @Override
+  public void drawRenderableImage(
+      RenderableImage img, AffineTransform xform) {
+    // TODO
+  }
+
+  @Override
+  public void drawString(String str, float x, float y) {
+    canvas.drawText(str, x, y, brush);
+  }
+
+  @Override
+  public void drawString(AttributedCharacterIterator iterator, float x, float y) {
+    drawString(iterator, (int) x, (int) y);
+  }
+
+  @Override
+  public void drawGlyphVector(GlyphVector g, float x, float y) {
+    // TODO
+  }
+
+  @Override
+  public void fill(Shape s) {
+    // TODO
+  }
+
+  @Override
+  public boolean hit(Rectangle rect, Shape s, boolean onStroke) {
+    // TODO
+    return false;
+  }
+
+  @Override
+  public GraphicsConfiguration getDeviceConfiguration() {
+    return null;
+  }
+
+  @Override
+  public void setRenderingHint(RenderingHints.Key hintKey, Object hintValue) {
+    renderingHints.put(hintKey, hintValue);
+  }
+
+  @Override
+  public Object getRenderingHint(RenderingHints.Key hintKey) {
+    return renderingHints.get(hintKey);
+  }
+
+  @Override
+  public void addRenderingHints(Map<?, ?> hints) {
+    renderingHints.putAll(hints);
+  }
+
+  @Override
+  public RenderingHints getRenderingHints() {
+    return renderingHints;
+  }
+
+  @Override
+  public void setRenderingHints(Map<?, ?> hints) {
+    renderingHints.clear();
+    renderingHints.putAll(hints);
+  }
+
+  @Override
+  public void translate(int x, int y) {
+    canvas.translate(x, y);
+  }
+
+  @Override
+  public void drawString(String str, int x, int y) {
+    drawString(str, (float) x, (float) y);
+  }
+
+  @Override
+  public synchronized void drawString(AttributedCharacterIterator iterator, int x, int y) {
+    SpannableStringBuilder formattedText = new SpannableStringBuilder();
+    int charsWritten = 0;
+    for (char c = iterator.first(); c != CharacterIterator.DONE; c = iterator.next()) {
+      formattedText.append(c);
+      charsWritten++;
+      Map<Attribute, Object> attributes = iterator.getAttributes();
+      if (!attributes.isEmpty()) {
+        new SkinJobTextAttributesDecoder(color)
+            .addAttributes(attributes)
+            .applyTo(formattedText, charsWritten - 1, charsWritten);
+      }
+    }
+    TextView formattedTextView = new TextView(SkinJob.getAndroidApplicationContext());
+    formattedTextView.setText(formattedText);
+    formattedTextView.layout(x, y, canvas.getWidth(), canvas.getHeight());
+    formattedTextView.draw(canvas);
+  }
+
+  @Override
+  public void translate(double tx, double ty) {
+    // TODO
+  }
+
+  @Override
+  public void rotate(double theta) {
+    // TODO
+  }
+
+  @Override
+  public void rotate(double theta, double x, double y) {
+    // TODO
+  }
+
+  @Override
+  public void scale(double sx, double sy) {
+    // TODO
+  }
+
+  @Override
+  public void shear(double shx, double shy) {
+    // TODO
+  }
+
+  @Override
+  public void transform(AffineTransform Tx) {
+    transform.concatenate(Tx);
+  }
+
+  @Override
+  public AffineTransform getTransform() {
+    return transform;
+  }
+
+  @Override
+  public void setTransform(AffineTransform Tx) {
+    transform = Tx;
+  }
+
+  @Override
+  public java.awt.Paint getPaint() {
+    return awtPaint;
+  }
+
+  @Override
+  public void setPaint(java.awt.Paint paint) {
+    awtPaint = paint;
+  }
+
+  @Override
+  public Composite getComposite() {
+    // TODO
+    return null;
+  }
+
+  @Override
+  public void setComposite(Composite comp) {
+    // TODO
+  }
+
+  @Override
+  public Color getBackground() {
+    // TODO
+    return null;
+  }
+
+  @Override
+  public void setBackground(Color color) {
+    // TODO
+  }
+
+  @Override
+  public synchronized Stroke getStroke() {
+    return stroke;
+  }
+
+  /**
+   * Support for this method is almost but not quite complete. {@link Stroke#createStrokedShape}
+   * will be called only from {@link #draw(Shape)}. However, if the stroke is a {@link BasicStroke},
+   * even through a subclass, then its line width, miter limit, join type and cap type (but not
+   * dashes) will be applied in other {@code draw*} methods as well.
+   *
+   * @param s the {@code Stroke} object to be used to stroke a
+   *          {@code Shape} during the rendering process
+   */
+  @Override
+  public synchronized void setStroke(Stroke s) {
+    stroke = s;
+    if (s instanceof BasicStroke) {
+      pen.setStrokeWidth(((BasicStroke) s).getLineWidth());
+      pen.setStrokeMiter(((BasicStroke) s).getMiterLimit());
+      int join = ((BasicStroke) s).getLineJoin();
+      switch (join) {
+        case JOIN_BEVEL:
+          pen.setStrokeJoin(Join.BEVEL);
+          break;
+        case JOIN_MITER:
+          pen.setStrokeJoin(Join.MITER);
+          break;
+        case JOIN_ROUND:
+          pen.setStrokeJoin(Join.ROUND);
+          break;
+        default:
+          Log.w(TAG, "Ignoring unknown stroke join type " + join);
+      }
+      int cap = ((BasicStroke) s).getEndCap();
+      switch (cap) {
+        case CAP_BUTT:
+          pen.setStrokeCap(Cap.BUTT);
+          break;
+        case CAP_ROUND:
+          pen.setStrokeCap(Cap.ROUND);
+          break;
+        case CAP_SQUARE:
+          pen.setStrokeCap(Cap.SQUARE);
+          break;
+        default:
+          Log.w(TAG, "Ignoring unknown stroke cap type " + join);
+      }
+    }
+  }
+
+  @Override
+  public void clip(Shape s) {
+    // TODO
+  }
+
+  @Override
+  public FontRenderContext getFontRenderContext() {
+    return null;
   }
 
   public Canvas getCanvas() {
Index: src/share/classes/java/awt/SkinJob.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/share/classes/java/awt/SkinJob.java	(date 1476782717000)
+++ src/share/classes/java/awt/SkinJob.java	(revision )
@@ -1,5 +1,24 @@
 package java.awt;
 
+import static java.awt.RenderingHints.KEY_ALPHA_INTERPOLATION;
+import static java.awt.RenderingHints.KEY_ANTIALIASING;
+import static java.awt.RenderingHints.KEY_COLOR_RENDERING;
+import static java.awt.RenderingHints.KEY_DITHERING;
+import static java.awt.RenderingHints.KEY_FRACTIONALMETRICS;
+import static java.awt.RenderingHints.KEY_INTERPOLATION;
+import static java.awt.RenderingHints.KEY_RENDERING;
+import static java.awt.RenderingHints.KEY_STROKE_CONTROL;
+import static java.awt.RenderingHints.KEY_TEXT_ANTIALIASING;
+import static java.awt.RenderingHints.VALUE_ALPHA_INTERPOLATION_QUALITY;
+import static java.awt.RenderingHints.VALUE_ANTIALIAS_ON;
+import static java.awt.RenderingHints.VALUE_COLOR_RENDER_QUALITY;
+import static java.awt.RenderingHints.VALUE_DITHER_ENABLE;
+import static java.awt.RenderingHints.VALUE_FRACTIONALMETRICS_OFF;
+import static java.awt.RenderingHints.VALUE_INTERPOLATION_BICUBIC;
+import static java.awt.RenderingHints.VALUE_RENDER_QUALITY;
+import static java.awt.RenderingHints.VALUE_STROKE_NORMALIZE;
+import static java.awt.RenderingHints.VALUE_TEXT_ANTIALIAS_ON;
+
 import android.R.color;
 import android.R.drawable;
 import android.content.Context;
@@ -10,6 +29,7 @@
 import java.awt.peer.ComponentPeer;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
+import java.util.HashMap;
 
 /**
  * Static members used to implement AWT on Android. Public mutable fields in this class control
@@ -19,8 +39,6 @@
 @SuppressWarnings("MagicNumber")
 public final class SkinJob {
 
-  private static volatile SkinJobGraphicsEnvironment graphicsEnvironment;
-
   /**
    * Conversion from an elliptical arc to a cubic Bezier spline is inherently approximate, and is
    * used in {@link java.awt.geom.ArcIterator}. The more segment endpoints the spline has, the
@@ -30,27 +48,21 @@
    * concentric true circles of radius 1.0 and radius 1.00027253.
    */
   public static final double maxDegreesPerArcSegment = 90.0;
-
-  private static final Resources systemResources = Resources.getSystem();
-
   /**
    * Default value for the miterLimit parameter of {@link
    * BasicStroke#BasicStroke(float, int, int, float)} when called from another constructor that
    * doesn't take that parameter. OpenJDK AWT uses 10.0f.
    */
   public static final float defaultMiterLimit = 10.0f;
-
   /**
    * Since Android only recognizes normal and bold, font weights greater than or equal to this
    * value become bold and the rest become normal.
    */
   public static final float boldThreshold = TextAttribute.WEIGHT_MEDIUM;
-
   /**
    * Whether {@link SkinJobListPeer#select(int)} should be animated.
    */
   public static final boolean animateListAutoSelection = true;
-
   /**
    * How far {@link SkinJobComponentPeerForView#setZOrder(ComponentPeer)} should place a
    * component in front of the other component, as a multiple of
@@ -58,18 +70,16 @@
    */
   public static final float layerZSpacing = 100.0f;
   public static final View menuDivider;
-
+  private static final Resources systemResources = Resources.getSystem();
   public static volatile int defaultForegroundColor = systemResources.getColor(
       color.primary_text_dark,
       systemResources.newTheme());
-
   /**
    * Height at which {@link FontMetrics} should report text is struck through, as a multiple of
    * {@link android.graphics.Paint.FontMetrics#ascent}. Doesn't affect the actual appearance of the
    * strikethrough, but must exist for backward-compatibility.
    */
   public static volatile float strikeThroughOffset = 0.5f;
-
   /*
    * Size of the array of precomputed character widths in each {@link FontMetrics}. Code points
    * lower than this value will be stored in the array; the rest will be recalculated on demand.
@@ -81,20 +91,33 @@
   public static volatile int defaultDragThreshold = 5;
   public static volatile int defaultFontSize = 12;
   public static volatile Font defaultFont = new Font(Font.DIALOG, Font.PLAIN, defaultFontSize);
+  public static RenderingHints defaultRenderingHints;
+  /**
+   * The application's {@link Context} instance. To maintain backward compatibility with AWT apps
+   * not designed for Android, SkinJob will look up the {@code Context} on demand if the application
+   * hasn't set this variable.
+   */
+  public static volatile Context registeredAndroidContext = null;
+  private static volatile SkinJobGraphicsEnvironment graphicsEnvironment;
 
   static {
     Context context = getAndroidApplicationContext();
     menuDivider = View.inflate(context,
         drawable.divider_horizontal_dim_dark,
         new ListView(context));
+    HashMap<RenderingHints.Key, Object> m = new HashMap<>();
+    m.put(KEY_ALPHA_INTERPOLATION, VALUE_ALPHA_INTERPOLATION_QUALITY);
+    m.put(KEY_ANTIALIASING, VALUE_ANTIALIAS_ON);
+    m.put(KEY_COLOR_RENDERING, VALUE_COLOR_RENDER_QUALITY);
+    m.put(KEY_DITHERING, VALUE_DITHER_ENABLE);
+    m.put(KEY_FRACTIONALMETRICS, VALUE_FRACTIONALMETRICS_OFF);
+    m.put(KEY_INTERPOLATION, VALUE_INTERPOLATION_BICUBIC);
+    m.put(KEY_RENDERING, VALUE_RENDER_QUALITY);
+    m.put(KEY_STROKE_CONTROL, VALUE_STROKE_NORMALIZE);
+    m.put(KEY_TEXT_ANTIALIASING, VALUE_TEXT_ANTIALIAS_ON);
+    // TODO: Is one of VALUE_TEXT_ANTIALIAS_LCD_* suitable for a typical mobile (OLED) screen?
+    defaultRenderingHints = new RenderingHints(m);
   }
-
-  /**
-   * The application's {@link Context} instance. To maintain backward compatibility with AWT apps
-   * not designed for Android, SkinJob will look up the {@code Context} on demand if the application
-   * hasn't set this variable.
-   */
-  public static volatile Context registeredAndroidContext = null;
 
   /**
    * Do not instantiate.
